// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"cloud.google.com/go/bigquery"
	"context"
	"github.com/m-mizutani/opac"
	"github.com/open-policy-agent/opa/v1/ast"
	"github.com/secmon-lab/overseer/pkg/domain/interfaces"
	"github.com/secmon-lab/overseer/pkg/domain/model"
	"io"
	"sync"
)

// Ensure, that CloudStorageClientMock does implement interfaces.CloudStorageClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.CloudStorageClient = &CloudStorageClientMock{}

// CloudStorageClientMock is a mock implementation of interfaces.CloudStorageClient.
//
//	func TestSomethingThatUsesCloudStorageClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.CloudStorageClient
//		mockedCloudStorageClient := &CloudStorageClientMock{
//			GetObjectFunc: func(ctx context.Context, bucketName string, objectName string) (io.ReadCloser, error) {
//				panic("mock out the GetObject method")
//			},
//			PutObjectFunc: func(ctx context.Context, bucketName string, objectName string) (io.WriteCloser, error) {
//				panic("mock out the PutObject method")
//			},
//		}
//
//		// use mockedCloudStorageClient in code that requires interfaces.CloudStorageClient
//		// and then make assertions.
//
//	}
type CloudStorageClientMock struct {
	// GetObjectFunc mocks the GetObject method.
	GetObjectFunc func(ctx context.Context, bucketName string, objectName string) (io.ReadCloser, error)

	// PutObjectFunc mocks the PutObject method.
	PutObjectFunc func(ctx context.Context, bucketName string, objectName string) (io.WriteCloser, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetObject holds details about calls to the GetObject method.
		GetObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BucketName is the bucketName argument value.
			BucketName string
			// ObjectName is the objectName argument value.
			ObjectName string
		}
		// PutObject holds details about calls to the PutObject method.
		PutObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BucketName is the bucketName argument value.
			BucketName string
			// ObjectName is the objectName argument value.
			ObjectName string
		}
	}
	lockGetObject sync.RWMutex
	lockPutObject sync.RWMutex
}

// GetObject calls GetObjectFunc.
func (mock *CloudStorageClientMock) GetObject(ctx context.Context, bucketName string, objectName string) (io.ReadCloser, error) {
	if mock.GetObjectFunc == nil {
		panic("CloudStorageClientMock.GetObjectFunc: method is nil but CloudStorageClient.GetObject was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		BucketName string
		ObjectName string
	}{
		Ctx:        ctx,
		BucketName: bucketName,
		ObjectName: objectName,
	}
	mock.lockGetObject.Lock()
	mock.calls.GetObject = append(mock.calls.GetObject, callInfo)
	mock.lockGetObject.Unlock()
	return mock.GetObjectFunc(ctx, bucketName, objectName)
}

// GetObjectCalls gets all the calls that were made to GetObject.
// Check the length with:
//
//	len(mockedCloudStorageClient.GetObjectCalls())
func (mock *CloudStorageClientMock) GetObjectCalls() []struct {
	Ctx        context.Context
	BucketName string
	ObjectName string
} {
	var calls []struct {
		Ctx        context.Context
		BucketName string
		ObjectName string
	}
	mock.lockGetObject.RLock()
	calls = mock.calls.GetObject
	mock.lockGetObject.RUnlock()
	return calls
}

// PutObject calls PutObjectFunc.
func (mock *CloudStorageClientMock) PutObject(ctx context.Context, bucketName string, objectName string) (io.WriteCloser, error) {
	if mock.PutObjectFunc == nil {
		panic("CloudStorageClientMock.PutObjectFunc: method is nil but CloudStorageClient.PutObject was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		BucketName string
		ObjectName string
	}{
		Ctx:        ctx,
		BucketName: bucketName,
		ObjectName: objectName,
	}
	mock.lockPutObject.Lock()
	mock.calls.PutObject = append(mock.calls.PutObject, callInfo)
	mock.lockPutObject.Unlock()
	return mock.PutObjectFunc(ctx, bucketName, objectName)
}

// PutObjectCalls gets all the calls that were made to PutObject.
// Check the length with:
//
//	len(mockedCloudStorageClient.PutObjectCalls())
func (mock *CloudStorageClientMock) PutObjectCalls() []struct {
	Ctx        context.Context
	BucketName string
	ObjectName string
} {
	var calls []struct {
		Ctx        context.Context
		BucketName string
		ObjectName string
	}
	mock.lockPutObject.RLock()
	calls = mock.calls.PutObject
	mock.lockPutObject.RUnlock()
	return calls
}

// Ensure, that BigQueryClientMock does implement interfaces.BigQueryClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.BigQueryClient = &BigQueryClientMock{}

// BigQueryClientMock is a mock implementation of interfaces.BigQueryClient.
//
//	func TestSomethingThatUsesBigQueryClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.BigQueryClient
//		mockedBigQueryClient := &BigQueryClientMock{
//			QueryFunc: func(ctx context.Context, query string) (interfaces.BigQueryIterator, *bigquery.JobStatistics, error) {
//				panic("mock out the Query method")
//			},
//		}
//
//		// use mockedBigQueryClient in code that requires interfaces.BigQueryClient
//		// and then make assertions.
//
//	}
type BigQueryClientMock struct {
	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, query string) (interfaces.BigQueryIterator, *bigquery.JobStatistics, error)

	// calls tracks calls to the methods.
	calls struct {
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
		}
	}
	lockQuery sync.RWMutex
}

// Query calls QueryFunc.
func (mock *BigQueryClientMock) Query(ctx context.Context, query string) (interfaces.BigQueryIterator, *bigquery.JobStatistics, error) {
	if mock.QueryFunc == nil {
		panic("BigQueryClientMock.QueryFunc: method is nil but BigQueryClient.Query was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
	}{
		Ctx:   ctx,
		Query: query,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, query)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedBigQueryClient.QueryCalls())
func (mock *BigQueryClientMock) QueryCalls() []struct {
	Ctx   context.Context
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Query string
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Ensure, that PubSubClientMock does implement interfaces.PubSubClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.PubSubClient = &PubSubClientMock{}

// PubSubClientMock is a mock implementation of interfaces.PubSubClient.
//
//	func TestSomethingThatUsesPubSubClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.PubSubClient
//		mockedPubSubClient := &PubSubClientMock{
//			PublishFunc: func(ctx context.Context, topic string, data []byte) error {
//				panic("mock out the Publish method")
//			},
//		}
//
//		// use mockedPubSubClient in code that requires interfaces.PubSubClient
//		// and then make assertions.
//
//	}
type PubSubClientMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, topic string, data []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic string
			// Data is the data argument value.
			Data []byte
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *PubSubClientMock) Publish(ctx context.Context, topic string, data []byte) error {
	if mock.PublishFunc == nil {
		panic("PubSubClientMock.PublishFunc: method is nil but PubSubClient.Publish was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Topic string
		Data  []byte
	}{
		Ctx:   ctx,
		Topic: topic,
		Data:  data,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, topic, data)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedPubSubClient.PublishCalls())
func (mock *PubSubClientMock) PublishCalls() []struct {
	Ctx   context.Context
	Topic string
	Data  []byte
} {
	var calls []struct {
		Ctx   context.Context
		Topic string
		Data  []byte
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that PolicyClientMock does implement interfaces.PolicyClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.PolicyClient = &PolicyClientMock{}

// PolicyClientMock is a mock implementation of interfaces.PolicyClient.
//
//	func TestSomethingThatUsesPolicyClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.PolicyClient
//		mockedPolicyClient := &PolicyClientMock{
//			MetadataFunc: func() ast.FlatAnnotationsRefSet {
//				panic("mock out the Metadata method")
//			},
//			QueryFunc: func(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error {
//				panic("mock out the Query method")
//			},
//		}
//
//		// use mockedPolicyClient in code that requires interfaces.PolicyClient
//		// and then make assertions.
//
//	}
type PolicyClientMock struct {
	// MetadataFunc mocks the Metadata method.
	MetadataFunc func() ast.FlatAnnotationsRefSet

	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error

	// calls tracks calls to the methods.
	calls struct {
		// Metadata holds details about calls to the Metadata method.
		Metadata []struct {
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Input is the input argument value.
			Input any
			// Output is the output argument value.
			Output any
			// Options is the options argument value.
			Options []opac.QueryOption
		}
	}
	lockMetadata sync.RWMutex
	lockQuery    sync.RWMutex
}

// Metadata calls MetadataFunc.
func (mock *PolicyClientMock) Metadata() ast.FlatAnnotationsRefSet {
	if mock.MetadataFunc == nil {
		panic("PolicyClientMock.MetadataFunc: method is nil but PolicyClient.Metadata was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMetadata.Lock()
	mock.calls.Metadata = append(mock.calls.Metadata, callInfo)
	mock.lockMetadata.Unlock()
	return mock.MetadataFunc()
}

// MetadataCalls gets all the calls that were made to Metadata.
// Check the length with:
//
//	len(mockedPolicyClient.MetadataCalls())
func (mock *PolicyClientMock) MetadataCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMetadata.RLock()
	calls = mock.calls.Metadata
	mock.lockMetadata.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *PolicyClientMock) Query(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error {
	if mock.QueryFunc == nil {
		panic("PolicyClientMock.QueryFunc: method is nil but PolicyClient.Query was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Input   any
		Output  any
		Options []opac.QueryOption
	}{
		Ctx:     ctx,
		Query:   query,
		Input:   input,
		Output:  output,
		Options: options,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, query, input, output, options...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedPolicyClient.QueryCalls())
func (mock *PolicyClientMock) QueryCalls() []struct {
	Ctx     context.Context
	Query   string
	Input   any
	Output  any
	Options []opac.QueryOption
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Input   any
		Output  any
		Options []opac.QueryOption
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Ensure, that CacheServiceMock does implement interfaces.CacheService.
// If this is not the case, regenerate this file with moq.
var _ interfaces.CacheService = &CacheServiceMock{}

// CacheServiceMock is a mock implementation of interfaces.CacheService.
//
//	func TestSomethingThatUsesCacheService(t *testing.T) {
//
//		// make and configure a mocked interfaces.CacheService
//		mockedCacheService := &CacheServiceMock{
//			NewReaderFunc: func(ctx context.Context, ID model.QueryID) (io.ReadCloser, error) {
//				panic("mock out the NewReader method")
//			},
//			NewWriterFunc: func(ctx context.Context, ID model.QueryID) (io.WriteCloser, error) {
//				panic("mock out the NewWriter method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedCacheService in code that requires interfaces.CacheService
//		// and then make assertions.
//
//	}
type CacheServiceMock struct {
	// NewReaderFunc mocks the NewReader method.
	NewReaderFunc func(ctx context.Context, ID model.QueryID) (io.ReadCloser, error)

	// NewWriterFunc mocks the NewWriter method.
	NewWriterFunc func(ctx context.Context, ID model.QueryID) (io.WriteCloser, error)

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// NewReader holds details about calls to the NewReader method.
		NewReader []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID model.QueryID
		}
		// NewWriter holds details about calls to the NewWriter method.
		NewWriter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID model.QueryID
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockNewReader sync.RWMutex
	lockNewWriter sync.RWMutex
	lockString    sync.RWMutex
}

// NewReader calls NewReaderFunc.
func (mock *CacheServiceMock) NewReader(ctx context.Context, ID model.QueryID) (io.ReadCloser, error) {
	if mock.NewReaderFunc == nil {
		panic("CacheServiceMock.NewReaderFunc: method is nil but CacheService.NewReader was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  model.QueryID
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockNewReader.Lock()
	mock.calls.NewReader = append(mock.calls.NewReader, callInfo)
	mock.lockNewReader.Unlock()
	return mock.NewReaderFunc(ctx, ID)
}

// NewReaderCalls gets all the calls that were made to NewReader.
// Check the length with:
//
//	len(mockedCacheService.NewReaderCalls())
func (mock *CacheServiceMock) NewReaderCalls() []struct {
	Ctx context.Context
	ID  model.QueryID
} {
	var calls []struct {
		Ctx context.Context
		ID  model.QueryID
	}
	mock.lockNewReader.RLock()
	calls = mock.calls.NewReader
	mock.lockNewReader.RUnlock()
	return calls
}

// NewWriter calls NewWriterFunc.
func (mock *CacheServiceMock) NewWriter(ctx context.Context, ID model.QueryID) (io.WriteCloser, error) {
	if mock.NewWriterFunc == nil {
		panic("CacheServiceMock.NewWriterFunc: method is nil but CacheService.NewWriter was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  model.QueryID
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockNewWriter.Lock()
	mock.calls.NewWriter = append(mock.calls.NewWriter, callInfo)
	mock.lockNewWriter.Unlock()
	return mock.NewWriterFunc(ctx, ID)
}

// NewWriterCalls gets all the calls that were made to NewWriter.
// Check the length with:
//
//	len(mockedCacheService.NewWriterCalls())
func (mock *CacheServiceMock) NewWriterCalls() []struct {
	Ctx context.Context
	ID  model.QueryID
} {
	var calls []struct {
		Ctx context.Context
		ID  model.QueryID
	}
	mock.lockNewWriter.RLock()
	calls = mock.calls.NewWriter
	mock.lockNewWriter.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *CacheServiceMock) String() string {
	if mock.StringFunc == nil {
		panic("CacheServiceMock.StringFunc: method is nil but CacheService.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedCacheService.StringCalls())
func (mock *CacheServiceMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Ensure, that NotifyServiceMock does implement interfaces.NotifyService.
// If this is not the case, regenerate this file with moq.
var _ interfaces.NotifyService = &NotifyServiceMock{}

// NotifyServiceMock is a mock implementation of interfaces.NotifyService.
//
//	func TestSomethingThatUsesNotifyService(t *testing.T) {
//
//		// make and configure a mocked interfaces.NotifyService
//		mockedNotifyService := &NotifyServiceMock{
//			PublishFunc: func(ctx context.Context, alert model.Alert) error {
//				panic("mock out the Publish method")
//			},
//		}
//
//		// use mockedNotifyService in code that requires interfaces.NotifyService
//		// and then make assertions.
//
//	}
type NotifyServiceMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, alert model.Alert) error

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alert is the alert argument value.
			Alert model.Alert
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *NotifyServiceMock) Publish(ctx context.Context, alert model.Alert) error {
	if mock.PublishFunc == nil {
		panic("NotifyServiceMock.PublishFunc: method is nil but NotifyService.Publish was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Alert model.Alert
	}{
		Ctx:   ctx,
		Alert: alert,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, alert)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedNotifyService.PublishCalls())
func (mock *NotifyServiceMock) PublishCalls() []struct {
	Ctx   context.Context
	Alert model.Alert
} {
	var calls []struct {
		Ctx   context.Context
		Alert model.Alert
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}
